import React, {useEffect, useMemo, useState} from "react";
import get from "lodash/get";
import {useFalcor} from '~/modules/avl-falcor';
import {pgEnv} from "~/utils/";
import {isJson} from "~/utils/macros.jsx";
import {RenderSocialVulnerabilitySummaryTable} from "./components/RenderSocialVulnerabilitySummaryTable.jsx";
import VersionSelectorSearchable from "../../components/versionSelector/searchable.jsx";
import GeographySearch from "../../components/geographySearch.jsx";
import {Loading} from "~/utils/loading.jsx";
import {RenderColumnControls} from "../../components/columnControls.jsx";
import {HazardSelectorSimple} from "../../components/HazardSelector/hazardSelectorSimple.jsx";
import {ButtonSelector} from "../../components/buttonSelector.jsx";
import VersionSelector from "../../components/versionSelector/index.jsx";
import {VersionSelectorMulti} from "../../components/versionSelector/VersionSelector.jsx";

const nameMapping = {
    'bin1': '0% - 20%',
    'bin2': '20% - 40%',
    'bin3': '40% - 60%',
    'bin4': '60% - 80%',
    'bin5': '80% +',
}
const Edit = ({value, onChange}) => {
    const {falcor, falcorCache} = useFalcor();

    let cachedData = value && isJson(value) ? JSON.parse(value) : {};
    const baseUrl = '/';

    const [dataSources, setDataSources] = useState(cachedData?.dataSources || []);
    const [dataSource, setDataSource] = useState(cachedData?.dataSource || []);
    const [version, setVersion] = useState(cachedData?.version || {});
    const [data, setData] = useState(cachedData?.data || []);

    const [loading, setLoading] = useState(true);
    const [status, setStatus] = useState(cachedData?.status);
    const [geoid, setGeoid] = useState(cachedData?.geoid || '36');
    const [visibleCols, setVisibleCols] = useState(cachedData?.visibleCols || 'num_tracts');

    const category = 'Social Vulnerability';

    const dataSourceByCategoryPath = ['dama', pgEnv, 'sources', 'byCategory', category];
    const attributionPath = version => ['dama', pgEnv, 'views', 'byId', version, 'attributes'],
        attributionAttributes = ['source_id', 'view_id', 'version', '_modified_timestamp'];

    const getRangeOptions = (geoAttribute, variable) => JSON.stringify({
        filter: {...geoAttribute && {[`substring(${geoAttribute}::text, 1, ${geoid?.length})`]: [geoid]}},
        exclude: {[variable]: [-999]}
    });
    const getRangeAttributes = (variable, popVariable) => [
        `SUM(${popVariable})::integer as population`,
        `MIN(${variable})::double precision as min`,
        `MAX(${variable})::double precision - MIN(${variable})::double precision as range`
    ];
    const getRangePath = (version, options) => ['dama', pgEnv, 'viewsbyId', version, 'options', options, 'databyIndex'];

    const options = geoAttribute => JSON.stringify({
        filter: {...geoAttribute && {[`substring(${geoAttribute}::text, 1, ${geoid?.length})`]: [geoid]}}
    });
    const attributes = (variable, min, range, popVariable) => [
        `sum(
            CASE WHEN ${variable}::double precision >= ${min} and ${variable}::double precision < (${range} * 0.2) + ${min}
            THEN ${popVariable ? `${popVariable}::integer` : `1`} ELSE 0
            END) as bin1`,
        `sum(
            CASE WHEN ${variable}::double precision >= (${range} * 0.2) + ${min} and ${variable}::double precision < (${range} * 0.4) + ${min}
            THEN ${popVariable ? `${popVariable}::integer` : `1`} ELSE 0
            END) as bin2`,
        `sum(
            CASE WHEN ${variable}::double precision >= (${range} * 0.4) + ${min} and ${variable}::double precision < (${range} * 0.6) + ${min}
            THEN ${popVariable ? `${popVariable}::integer` : `1`} ELSE 0
            END) as bin3`,
        `sum(
            CASE WHEN ${variable}::double precision >= (${range} * 0.6) + + ${min} and ${variable}::double precision < (${range} * 0.8) + ${min}
            THEN ${popVariable ? `${popVariable}::integer` : `1`} ELSE 0
            END) as bin4`,
        `sum(
            CASE WHEN ${variable}::double precision >= (${range} * 0.8) + ${min}
            THEN ${popVariable ? `${popVariable}::integer` : `1`} ELSE 0
            END) as bin5`
    ];
    const dataPath = (version, options) => ['dama', pgEnv, 'viewsbyId', version, 'options', options, 'databyIndex'];

    useEffect(() => {
        async function getData() {
            setLoading(true);
            setStatus(undefined);

            // fetch data sources from categories that match passed prop
            await falcor.get(dataSourceByCategoryPath);
            setDataSources(get(falcor.getCache(), [...dataSourceByCategoryPath, 'value'], []))
            // fetch columns, data

            setLoading(false);

        }

        getData()
    }, []);

    useEffect(() => {
        async function getData() {
            if (!version || !dataSource.length) {
                !dataSource.length && setStatus('Please select a Datasource.');
                !version && setStatus('Please select a version.');
                setLoading(false);
                return;
            }
            setLoading(true);
            setStatus(undefined);
            // for each dataset, hardcode a variable (later allow dropdown selection
            // for that variable, and for all geoids, fetch range
            // for the fetched range, fetch bins.
            // bins can be: sum of # of tracts;
            // % affected population in those bins
            // set data: [{'dataset name': {bin#: value}}]

            const tmp_variables = {
                352: {data: 'RPL_THEMES', population: 'E_TOTPOP'},
                353: {data: 'COMB_SC', population: 'POP_CNT'},
                354: {data: 'TC', population: 'TPF'}
            }
            const getRangePaths = Object.keys(version || {})
                .filter(source => version[source])
                .map(source => {
                    // get geoAttribute for this source
                    // build getRange path
                    const currentDataSource = dataSources.find(ds => ds.source_id == source);
                    const currentGeoAttribute = currentDataSource?.metadata?.find(md => md.display === 'geoid-variable')?.name;
                    const currentVariable = tmp_variables[source].data;
                    const popVariable = tmp_variables[source].population;

                    const currentOptions = getRangeOptions(currentGeoAttribute, currentVariable);

                    return [...getRangePath(version[source], currentOptions), {
                        from: 0,
                        to: 0
                    }, getRangeAttributes(currentVariable, popVariable)]
                })

            if (!getRangePaths.length) return;

            await falcor.get(...getRangePaths);

            const getDataPaths = Object.keys(version || {})
                .filter(source => version[source])
                .map(source => {
                    // get geoAttribute for this source
                    // build getRange path
                    const currentDataSource = dataSources.find(ds => ds.source_id == source);
                    const currentGeoAttribute = currentDataSource?.metadata?.find(md => md.display === 'geoid-variable')?.name;
                    const currentVariable = tmp_variables[source].data;
                    const popVariable = tmp_variables[source].population;

                    const currentOptions = getRangeOptions(currentGeoAttribute, currentVariable);
                    const currentRangeRes = get(falcor.getCache(), [...getRangePath(version[source], currentOptions), 0], {});

                    const currentRange = Object.keys(currentRangeRes).reduce((acc, curr) => {
                        acc[curr.split('as ')[1]] = currentRangeRes[curr];
                        return acc;
                    }, {})

                    const dataOptions = options(currentGeoAttribute);
                    return [
                        ...dataPath(version[source], dataOptions), {from: 0, to: 0},
                        attributes(currentVariable, currentRange.min, currentRange.range, visibleCols === 'pct_population' ? popVariable : undefined)
                            ]
                })

            if (!getDataPaths.length) return;
            await falcor.get(...getDataPaths);

            const data = Object.keys(version || {})
                .filter(source => version[source] && dataSource.includes(parseInt(source)))
                .map(source => {
                    const currentDataSource = dataSources.find(ds => ds.source_id == source);
                    const currentGeoAttribute = currentDataSource?.metadata?.find(md => md.display === 'geoid-variable')?.name;
                    const currentVariable = tmp_variables[source].data;

                    const currentOptions = getRangeOptions(currentGeoAttribute, currentVariable);
                    const currentRangeRes = get(falcor.getCache(), [...getRangePath(version[source], currentOptions), 0], {});
                    const currentRange = Object.keys(currentRangeRes).reduce((acc, curr) => {
                        acc[curr.split('as ')[1]] = currentRangeRes[curr];
                        return acc;
                    }, {})

                    const dataOptions = options(currentGeoAttribute);
                    const dataRes = get(falcor.getCache(), [...dataPath(version[source], dataOptions), 0], {});

                    const data = Object.keys(dataRes).reduce((acc, curr) => {
                        const currentValue =
                            visibleCols === 'pct_population' ?
                                `${(((dataRes[curr] / (currentRange?.population || 1)) * 100) || 0).toFixed(2)} %` :
                                dataRes[curr];

                        acc[curr.split('as ')[1]] = currentValue;
                        return acc;
                    }, {})

                    return {
                        dataset: currentDataSource?.name,
                        ...data
                    }
                });
            setData(data);

            await falcor.get([...attributionPath(Object.values(version)), attributionAttributes]);

            setLoading(false);

        }

        getData()
    }, [dataSource, version, geoid, visibleCols]);

    const attributionData = Object.values(version || {}).map (v => get(falcorCache, attributionPath(v), {}));

    // 0-0.2 | 0.2-0.4 | 0.4-0.6 | 0.6-0.8 | 0.8+
    // CDC SVI
    // total tract pop E_TOTPOP
    // overall ranking RPL_THEMES

    // NYSERDA DAC
    // total tract pop POP_CNT
    // overall ranking COMB_SC

    // CJEST
    // total tract pop TPF
    // overall ranking TC 0-2 | 3-5 | 6-8 | 9-12 | 13+
    const columns =
        useMemo(() =>
            Object.keys(data[0] || {})
            .map(column => ({
                Header: nameMapping[column] || column,
                accessor: column
            })), [data]);

    useEffect(() => {
            if (!loading) {
                onChange(JSON.stringify(
                    {
                        attributionData,
                        status,
                        geoid,
                        // pageSize, sortBy,
                        data, columns,
                        // filters, filterValue,
                        visibleCols,
                        dataSource, dataSources, version
                    }))
            }
        },
        [attributionData, status, geoid,
            // pageSize, sortBy,
            data, columns,
            // filters, filterValue,
            visibleCols,
            dataSource, dataSources, version
        ]);

    return (
        <div className='w-full'>
            <div className='relative'>
                <div className={'border rounded-md border-blue-500 bg-blue-50 p-2 m-1'}>
                    Edit Controls
                    <ButtonSelector
                        label={'Data Source:'}
                        multi={true}
                        types={dataSources.map(ds => ({label: ds.name, value: ds.source_id}))}
                        type={dataSource}
                        setType={setDataSource}
                    />
                    <VersionSelectorMulti
                        versions={
                            typeof dataSource === 'object' && dataSource.reduce((acc, ds) => ({
                                ...acc,
                                [ds]: version[ds]
                            }), {})
                        }
                        onChange={setVersion}
                        className={'flex-row-reverse'}
                    />
                    <GeographySearch value={geoid} onChange={setGeoid} className={'flex-row-reverse'}/>

                    <ButtonSelector
                        label={'Display:'}
                        types={[{label: '# Tracts', value: 'num_tracts'}, {label: '% Population', value: 'pct_population'}]}
                        type={visibleCols}
                        setType={setVisibleCols}
                    />
                </div>
                {
                    loading ? <Loading/> :
                        status ? <div className={'p-5 text-center'}>{status}</div> :
                            <RenderSocialVulnerabilitySummaryTable
                                data={data}
                                columns={columns}
                                // pageSize={pageSize}
                                attributionData={attributionData}
                                baseUrl={baseUrl}
                            />

                }
            </div>
        </div>
    )
}

Edit.settings = {
    hasControls: true,
    name: 'ElementEdit'
}

const View = ({value}) => {
    if (!value) return ''

    let data = typeof value === 'object' ?
        value['element-data'] :
        JSON.parse(value)
    return (
        <div className='relative w-full p-6'>
            {
                data?.status ?
                    <div className={'p-5 text-center'}>{data?.status}</div> :
                    <RenderSocialVulnerabilitySummaryTable {...data} baseUrl={'/'}/>
            }
        </div>
    )
}


export default {
    "name": 'Table: Social Vulnerability Summary',
    "type": 'Table',
    "EditComp": Edit,
    "ViewComp": View
}