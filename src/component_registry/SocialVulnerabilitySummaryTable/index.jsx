import React, {useEffect, useMemo, useState} from "react";
import get from "lodash/get";
import {useFalcor} from '~/modules/avl-falcor';
import {pgEnv} from "~/utils/";
import {isJson} from "~/utils/macros.jsx";
import {RenderSocialVulnerabilitySummaryTable} from "./components/RenderSocialVulnerabilitySummaryTable.jsx";
import VersionSelectorSearchable from "../shared/versionSelector/searchable.jsx";
import GeographySearch from "../shared/geographySearch.jsx";
import {Loading} from "~/utils/loading.jsx";
import {RenderColumnControls} from "../shared/columnControls.jsx";
import {HazardSelectorSimple} from "../shared/HazardSelector/hazardSelectorSimple.jsx";
import {ButtonSelector} from "../shared/buttonSelector.jsx";
import VersionSelector from "../shared/versionSelector/index.jsx";
import {VersionSelectorMulti} from "../shared/versionSelector/VersionSelector.jsx";

// 0-0.2 | 0.2-0.4 | 0.4-0.6 | 0.6-0.8 | 0.8+
// CDC SVI
// total tract pop E_TOTPOP
// overall ranking RPL_THEMES

// NYSERDA DAC
// total tract pop POP_CNT
// overall ranking COMB_SC // rank raw?
// for all maps, add feature to add basemap to add more context

// CJEST
// total tract pop TPF
// overall ranking TC 0-2 | 3-5 | 6-8 | 9-12 | 13+

const nameMapping = {
    'bin1': 'Low Vulnerability',
    'bin2': 'Medium Low',
    'bin3': 'Medium',
    'bin4': 'Medium High',
    'bin5': 'High Vulnerability',
}

const tmp_variables = {
    378: {data: 'RPL_THEMES', population: 'E_TOTPOP'},
    352: {data: 'RPL_THEMES', population: 'E_TOTPOP'},
    353: {data: 'COMB_SC', population: 'POP_CNT'},
    354: {data: 'TC', population: 'TPF'}
}
async function getData({version, dataSources, dataSource, geoid, visibleCols}, falcor) {
    // for each dataset, hardcode a variable (later allow dropdown selection
    // for that variable, and for all geoids, fetch range
    // for the fetched range, fetch bins.
    // bins can be: sum of # of tracts;
    // % affected population in those bins
    // set data: [{'dataset name': {bin#: value}}]
    const category = 'Social Vulnerability';

    const dataSourceByCategoryPath = ['dama', pgEnv, 'sources', 'byCategory', category];
    const attributionPath = version => ['dama', pgEnv, 'views', 'byId', version, 'attributes'],
        attributionAttributes = ['source_id', 'view_id', 'version', '_modified_timestamp'];

    const getRangeOptions = (geoAttribute, variable) => JSON.stringify({
        filter: {...geoAttribute && {[`substring(${geoAttribute}::text, 1, ${geoid?.toString()?.length})`]: [geoid]}},
        exclude: {[variable]: [-999]}
    });
    const getRangeAttributes = (variable, popVariable) => [
        `SUM(${popVariable})::integer as population`,
        `MIN(${variable})::double precision as min`,
        `MAX(${variable})::double precision - MIN(${variable})::double precision as range`
    ];
    const getRangePath = (version, options) => ['dama', pgEnv, 'viewsbyId', version, 'options', options, 'databyIndex'];

    const options = geoAttribute => JSON.stringify({
        filter: {...geoAttribute && {[`substring(${geoAttribute}::text, 1, ${geoid?.toString()?.length})`]: [geoid]}}
    });
    const attributes = (variable, min, range, popVariable) => [
        `sum(
            CASE WHEN ${variable}::double precision >= ${min} and ${variable}::double precision < (${range} * 0.2) + ${min}
            THEN ${popVariable ? `${popVariable}::integer` : `1`} ELSE 0
            END) as bin1`,
        `sum(
            CASE WHEN ${variable}::double precision >= (${range} * 0.2) + ${min} and ${variable}::double precision < (${range} * 0.4) + ${min}
            THEN ${popVariable ? `${popVariable}::integer` : `1`} ELSE 0
            END) as bin2`,
        `sum(
            CASE WHEN ${variable}::double precision >= (${range} * 0.4) + ${min} and ${variable}::double precision < (${range} * 0.6) + ${min}
            THEN ${popVariable ? `${popVariable}::integer` : `1`} ELSE 0
            END) as bin3`,
        `sum(
            CASE WHEN ${variable}::double precision >= (${range} * 0.6) + + ${min} and ${variable}::double precision < (${range} * 0.8) + ${min}
            THEN ${popVariable ? `${popVariable}::integer` : `1`} ELSE 0
            END) as bin4`,
        `sum(
            CASE WHEN ${variable}::double precision >= (${range} * 0.8) + ${min}
            THEN ${popVariable ? `${popVariable}::integer` : `1`} ELSE 0
            END) as bin5`
    ];
    const dataPath = (version, options) => ['dama', pgEnv, 'viewsbyId', version, 'options', options, 'databyIndex'];


    await falcor.get(dataSourceByCategoryPath);
    dataSources = get(falcor.getCache(), [...dataSourceByCategoryPath, 'value'], []);
    if(!dataSource?.length) {
        dataSource = [dataSources[0]?.source_id];
        return {
            dataSources,
            dataSource,
            geoid,
            visibleCols
        }
    }

    const getRangePaths = Object.keys(version || {})
        .filter(source => version[source])
        .map(source => {
            // get geoAttribute for this source
            // build getRange path
            const currentDataSource = dataSources.find(ds => ds.source_id == source);

            const currentGeoAttribute = (currentDataSource?.metadata?.columns || currentDataSource?.metadata || [])?.find(md => md.display === 'geoid-variable')?.name;
            const currentVariable = tmp_variables[+source].data;
            const popVariable = tmp_variables[+source].population;

            const currentOptions = getRangeOptions(currentGeoAttribute, currentVariable);

            return [...getRangePath(version[source], currentOptions), {
                from: 0,
                to: 0
            }, getRangeAttributes(currentVariable, popVariable)]
        })

    if (!getRangePaths.length) return;

    await falcor.get(...getRangePaths);

    const getDataPaths = Object.keys(version || {})
        .filter(source => version[source])
        .map(source => {
            // get geoAttribute for this source
            // build getRange path
            const currentDataSource = dataSources.find(ds => ds.source_id == source);
            const currentGeoAttribute = (currentDataSource?.metadata?.columns || currentDataSource?.metadata || [])?.find(md => md.display === 'geoid-variable')?.name;
            const currentVariable = tmp_variables[+source].data;
            const popVariable = tmp_variables[+source].population;

            const currentOptions = getRangeOptions(currentGeoAttribute, currentVariable);
            const currentRangeRes = get(falcor.getCache(), [...getRangePath(version[source], currentOptions), 0], {});

            const currentRange = Object.keys(currentRangeRes).reduce((acc, curr) => {
                acc[curr.split('as ')[1]] = currentRangeRes[curr];
                return acc;
            }, {})

            const dataOptions = options(currentGeoAttribute);
            return [
                ...dataPath(version[source], dataOptions), {from: 0, to: 0},
                attributes(currentVariable, currentRange.min, currentRange.range, visibleCols === 'pct_population' ? popVariable : undefined)
            ]
        })

    if (!getDataPaths.length) return;
    await falcor.get(...getDataPaths);

    const data = Object.keys(version || {})
        .filter(source => version[source] && dataSource.includes(parseInt(source)))
        .map(source => {
            const currentDataSource = dataSources.find(ds => ds.source_id == source);
            const currentGeoAttribute = (currentDataSource?.metadata?.columns || currentDataSource?.metadata || [])?.find(md => md.display === 'geoid-variable')?.name;
            const currentVariable = tmp_variables[+source].data;

            const currentOptions = getRangeOptions(currentGeoAttribute, currentVariable);
            const currentRangeRes = get(falcor.getCache(), [...getRangePath(version[source], currentOptions), 0], {});
            const currentRange = Object.keys(currentRangeRes).reduce((acc, curr) => {
                acc[curr.split('as ')[1]] = currentRangeRes[curr];
                return acc;
            }, {})

            const dataOptions = options(currentGeoAttribute);
            const dataRes = get(falcor.getCache(), [...dataPath(version[source], dataOptions), 0], {});

            const data = Object.keys(dataRes).reduce((acc, curr) => {
                const currentValue =
                    visibleCols === 'pct_population' ?
                        `${(((dataRes[curr] / (currentRange?.population || 1)) * 100) || 0).toFixed(2)} %` :
                        dataRes[curr];

                acc[curr.split('as ')[1]] = currentValue;
                return acc;
            }, {})

            return {
                dataset: currentDataSource?.name,
                ...data
            }
        });
    const attributionDataRes = await falcor.get([...attributionPath(Object.values(version)), attributionAttributes]);
    const attributionData = Object.values(version || {}).map (v => get(attributionDataRes, ['json', ...attributionPath(v)], {}));

    const columns = Object.keys(data[0] || {})
        .map(column => ({
            Header: nameMapping[column] || column,
            accessor: column
        }))

    return {
        data,
        attributionData, // check for acuracy
        columns,
        version,
        dataSources,
        dataSource,
        geoid,
        visibleCols
    }
}
const Edit = ({value, onChange}) => {
    const {falcor, falcorCache} = useFalcor();

    let cachedData = value && isJson(value) ? JSON.parse(value) : {};
    const baseUrl = '/';

    const [dataSource, setDataSource] = useState(cachedData?.dataSource || []);
    const [version, setVersion] = useState(cachedData?.version || {});
    const [loading, setLoading] = useState(true);
    const [status, setStatus] = useState(cachedData?.status);
    const [geoid, setGeoid] = useState(cachedData?.geoid || '36');
    const [visibleCols, setVisibleCols] = useState(cachedData?.visibleCols || 'num_tracts');

    useEffect(() => {
        async function load(){
            setLoading(true);
            setStatus(undefined);
            const data = await getData({
                version, dataSources: cachedData.dataSources, dataSource, geoid, visibleCols
            }, falcor);
            onChange(JSON.stringify({
                ...data,
            }));
            setLoading(false);
        }

        load()
    }, [dataSource, version, geoid, visibleCols]);

    return (
        <div className='w-full'>
            <div className='relative'>
                <div className={'border rounded-md border-blue-500 bg-blue-50 p-2 m-1'}>
                    Edit Controls
                    <ButtonSelector
                        label={'Data Source:'}
                        multi={true}
                        types={(cachedData.dataSources || []).map(ds => ({label: ds.name, value: ds.source_id}))}
                        type={dataSource}
                        setType={setDataSource}
                    />
                    <VersionSelectorMulti
                        versions={
                            typeof dataSource === 'object' && dataSource.reduce((acc, ds) => ({
                                ...acc,
                                [ds]: version[ds]
                            }), {})
                        }
                        onChange={setVersion}
                        className={'flex-row-reverse'}
                    />
                    <GeographySearch value={geoid} onChange={setGeoid} className={'flex-row-reverse'}/>

                    <ButtonSelector
                        label={'Display:'}
                        types={[{label: '# Tracts', value: 'num_tracts'}, {label: '% Population', value: 'pct_population'}]}
                        type={visibleCols}
                        setType={setVisibleCols}
                    />
                </div>
                {
                    loading ? <Loading/> :
                        status ? <div className={'p-5 text-center'}>{status}</div> :
                            <RenderSocialVulnerabilitySummaryTable
                                data={cachedData.data}
                                columns={cachedData.columns}
                                // pageSize={pageSize}
                                attributionData={cachedData.attributionData}
                                baseUrl={baseUrl}
                            />

                }
            </div>
        </div>
    )
}

Edit.settings = {
    hasControls: true,
    name: 'ElementEdit'
}

const View = ({value}) => {
    if (!value) return ''

    let data = typeof value === 'object' ?
        value['element-data'] :
        JSON.parse(value)
    return (
        <div className='relative w-full p-6'>
            {
                data?.status ?
                    <div className={'p-5 text-center'}>{data?.status}</div> :
                    <RenderSocialVulnerabilitySummaryTable {...data} baseUrl={'/'}/>
            }
        </div>
    )
}


export default {
    "name": 'Table: Social Vulnerability Summary',
    "type": 'Table',
    "variables": [
        {
            name: 'version',
            default: {},
            hidden: true
        },
        {
            name: 'dataSources',
            default: [],
            hidden: true
        },
        {
            name: 'dataSource',
            default: [],
            hidden: true
        },
        {
            name: 'geoid',
            default: '36'
        },
        {
            name: 'visibleCols',
            default: 'num_tracts',
            hidden: true
        },
    ],
    getData,
    "EditComp": Edit,
    "ViewComp": View
}